**垃圾收集**

判断对象死亡
* 引用计数算法：给对象添加一个引用计数器，每当该对象被引用，则引用计数器的值 加一，每当一个引用失效的时候
该计数器的值 减一，当引用计数器的值为 0 表明该对象 已经无法 在使用
    缺点：无法解决循环依赖的问题
* 根搜索算法：通过一系列的 “GC ROOTS”为起始点，向下搜索，搜索所走过的路径成为引用链，当一个对象到“GC ROOTS“
没有任何一个引用链 相连，说明该对象 是不可用的


**垃圾收集算法**
* 标记-清除算法：首先标记出 所有需要回收的对象，在标记完成后，在统一回收所有被标记的对象
    缺点：1.效率问题  2. 空间问题
    
* 复制算法：把空间分为大小相等的两快，每次只使用其中一快，当这一块内存使用完，把存活的对象拷贝
到未使用的内存上，在一次清除已经使用掉的内存
    (回收新生代)把空间分为 Eden空间 和较小的两块 Survivor空间，每次只使用 Eden 和其中一个Survivor 空间，当回收
时，把Eden 和Survivor空间存活的对象一次性拷贝到 另外一块Survivor 空间，然后清理到 Eden和使用过的
Survivor空间        
    缺点：浪费一半空间，或者 使用Eden 空间模式 需要额外 空间进行担保
* 标记-整理算法：（老年代特点：对象存活比例高）
    和标记-清除算法第一步一样进行标记，然后不是进行清除，而是 把所有存活的对象移动到一端，把端边界以外的部分进行清除
    
* 分代收集算法：根据对象存活周期不同，把内存划分不同区域。把java堆 分为新生代和老年代
    新生代：对象大批死亡（朝生夕死）    适合 复制算法
    老年代：对象存活率高，适合 标记-清除 或者标记-整理